package repo

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/filemode"
	"github.com/go-git/go-git/v5/plumbing/object"
	"go.uber.org/zap"
)

type sharedBase struct {
	ConcurrentConnections *uint `yaml:"concurrent_connections"`

	Timeout  *time.Duration `yaml:"timeout"`
	Cooldown *time.Duration `yaml:"cooldown"`
	Retries  *uint          `yaml:"retries"`

	ObfuscateTraffic *bool `yaml:"obfuscate_traffic"`

	OnlyTeams []string `yaml:"only_teams"`
	SkipTeams []string `yaml:"skip_teams"`
}

type Exploit struct {
	sharedBase
	ExtractPath           string
	HasDockerFile         bool
	ConcurrentConnections uint
	TreeHash              plumbing.Hash
}

func checkExploit(ctx context.Context, logger *zap.Logger, tree *object.Tree) error {
	exploitConfigFile, err := tree.File("config.yaml")

	if err != nil {
		if !errors.Is(err, object.ErrFileNotFound) {
			return err
		}
	} else if err := parseYaml(ctx, logger, exploitConfigFile, &new(Exploit).sharedBase); err != nil {
		return fmt.Errorf("failed to parse exploit config: %w", err)
	}

	exploitFile, err := tree.File("exploit")
	if err != nil {
		return err
	}
	if exploitFile.Mode != filemode.Executable {
		return errors.New("exploit file is not executable")
	}

	dockerFile, err := tree.File("Dockerfile")
	if err == nil {
		if !dockerFile.Mode.IsRegular() {
			return errors.New(`"Dockerfile" exists but not a regular file`)
		}
	} else if !errors.Is(err, object.ErrFileNotFound) {
		return err
	}

	return nil
}

func loadExploit(ctx context.Context, logger *zap.Logger, repo *git.Repository, tree *object.Tree) (*Exploit, error) {
	exploitConfigFile, err := tree.File("config.yaml")

	exploit := &Exploit{TreeHash: tree.Hash}
	if err != nil {
		if !errors.Is(err, object.ErrFileNotFound) {
			logger.Error("failed to get exploit config file", zap.Error(err))
			return nil, err
		}
		logger.Debug("exploit config file not found, using default config")
	} else if err := parseYaml(ctx, logger, exploitConfigFile, &exploit.sharedBase); err != nil {
		logger.Warn("failed to parse exploit config, using default config", zap.Error(err))
	}

	exploitFile, err := tree.File("exploit")
	if err != nil {
		logger.Error("failed to get exploit file", zap.Error(err))
		return nil, err
	}
	if exploitFile.Mode != filemode.Executable {
		logger.Warn("exploit file is not executable")
		return nil, err
	}

	if exploit.sharedBase.ConcurrentConnections != nil {
		exploit.ConcurrentConnections = *exploit.sharedBase.ConcurrentConnections
	} else {
		exploit.ConcurrentConnections = 1 // default to 1 concurrent connection
	}

	dockerFile, err := tree.File("Dockerfile")
	if err == nil {
		if dockerFile.Mode.IsRegular() {
			exploit.HasDockerFile = true
		} else {
			logger.Warn("Dockerfile exists but not a regular file", zap.Stringer("mode", dockerFile.Mode))
		}
	} else if !errors.Is(err, object.ErrFileNotFound) {
		logger.Error("failed to get Dockerfile", zap.Error(err))
	}

	// extract the exploit to a folder
	tempDir, err := extractTreeToDir(logger, repo, tree)
	if err != nil {
		logger.Error("failed to extract tree for exploit", zap.Error(err))
		return nil, err
	}
	exploit.ExtractPath = tempDir

	return exploit, nil
}
